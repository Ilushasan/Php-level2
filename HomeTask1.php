<?php
//1. Придумать класс, который описывает любую сущность из предметной области интернет-магазинов: продукт, ценник, посылка и т.п.
//2. Описать свойства класса из п.1 (состояние).
//3. Описать поведение класса из п.1 (методы).
//4. Придумать наследников класса из п.1. Чем они будут отличаться?
//Ответ:
class Goods{//Общий класс описывающий все основные сущности
    private $id;//Все товары имеют уникальный id, поэтому свой-во общее
    private $title;//Все товары имеют название или имя, поэтому свой-во общее
    private $price;//Все товары имеют цену, поэтому свой-во общее

    public function getTitle(){
        return $this->title;
    }
    public function getPrice(){
        return $this->price;
    }
    public function getId()
    {
        return $this->id;
    }
    function __construct($title,$price, $id){
        $this->title = $title;
        $this->price = $price;
        $this->id = $id;
    }
    function makeAnOrder(){}//Метод позволяющий сделать заказ
    function delivery(){}//Метод позволяющий оформить доставку
}

class Electronics extends Goods{//Дочерний класс от goods, описывающий общие сущности для электроники
    public function __construct($title, $price, $id, $type, $count)//Добавляется тип устройства, общее кол-во товаров
    {
        parent::__construct($title, $price, $id);
    }
    function specialistConsultation(){}//Метод позволяющий получить консультацию специалиста
}

class Phone extends Electronics{//Дочерний класс от электроники, описывающий сущности конкретно для телефона
    public function __construct($title, $price, $id, $type, $count, $acces)//Добавляются разные комплектующий/акссесуары
    {
        parent::__construct($title, $price, $id, $type, $count);
    }
    function changeColor(){}//Метод позволяющий выбрать цвет
    function chooseScpec(){}//Выбрать нужные характеристики
}
class TV extends Electronics{//Дочерний класс от электроники, описывающий сущности конкретно для телевизоров
    public function __construct($title, $price, $id, $type, $count, $matrics)//Д
    {
        parent::__construct($title, $price, $id, $type, $count);
    }
    function chooseMatcrics(){}//Выбрать матрицу
    function chooseDiag(){}//Выбрать диагональ
}
//5. Дан код:
//class A {
//    public function foo() {
//        static $x = 0;
//        echo ++$x;
//    }
//}
//$a1 = new A();
//$a2 = new A();
//$a1->foo();
//$a2->foo();
//$a1->foo();
//$a2->foo();
//Что он выведет на каждом шаге? Почему?
//Ответ на 5 вопрос:
//В данном случае инкремент префиксны, благодаря этому сначала производится рассчет, а после вывод.
//Вывод: 1234

//=============================================

//    Немного изменим п.5:
//class A {
//    public function foo() {
//        static $x = 0;
//        echo ++$x;
//    }
//}
//class B extends A {
//}
//$a1 = new A();
//$b1 = new B();
//$a1->foo();
//$b1->foo();
//$a1->foo();
//$b1->foo();
////6. Объясните результаты в этом случае.
//Ответ на 6 вопрос: Разница с предыдущим примером всего лишь в том, что класс B является дочерним и наследуемая функция
//foo является отдельной, самостоятельной функцией, которая хранит свое значение.
//Поэтому при данном выводе рассчет происходит в разных классах, в разных функциях
//Вывод: 1122

//=============================================

////7. *Дан код:
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
class B extends A {
}
$a1 = new A;
$b1 = new B;
$a1->foo();
$b1->foo();
$a1->foo();
$b1->foo();
//Что он выведет на каждом шаге? Почему?
//Ответ на 7 вопрос: не совсем понимаю вопроса, т.к. этот код идентичен коду из 6 задания, но попытаюсь пошагово описать.
//После наследования класса изначальным значение переменной х было 0 в обоих классах
//После первого вызова $a1->foo(); происходит прибавление единицы к переменно х в классе А в фук-ции foo и вывод 1
//После первого вызова $b1->foo(); происходит прибавление единицы к переменно х в классе B в фук-ции foo и вывод 1
//После второго вызова $a1->foo(); происходит прибавление единицы к переменно х(которая уже равна 1) в классе A в фук-ции foo и вывод 2
//После второго вызова $b1->foo(); происходит прибавление единицы к переменно х(которая уже равна 1) в классе B в фук-ции foo и вывод 2